<template>
	<!-- #ifndef MP-WEIXIN -->
	<view :class="fabClass" :style="[floatFabStyle,customStyle]" ref="fabRef" @touchstart="onTouchstart"
		@touchmove="onTouchmove" @touchend="onTouchend" @touchcancel="onTouchend">
		<slot>
			<rice-icon v-if="hasStrValue(icon)" :name="icon" :color="iconColor" :size="iconSize" />
		</slot>
	</view>
	<!-- #endif -->

	<!-- #ifdef MP-WEIXIN -->
	<view :class="fabClass" :style="[floatFabStyle,customStyle]" :state="state" :change:state="wxs.updateState"
		:boundary="boundary" :change:boundary="wxs.updateBoundary" :mpProps="mpProps" :change:mpProps="wxs.updateMpProps"
		ref="fabRef" @touchstart="wxs.onTouchstart" @touchmove="wxs.onTouchmove" @touchend="wxs.onTouchend"
		@touchcancel="wxs.onTouchend" @click="handleClick">
		<slot>
			<rice-icon v-if="hasStrValue(icon)" :name="icon" :color="iconColor" :size="iconSize" />
		</slot>
	</view>
	<!-- #endif -->

</template>

<script setup>
	/**
	 * @description FloatFab悬浮球
	 * @property {Object} offset 悬浮球的位置，{x:number,y:number}，默认{x:-1,y:-1}
	 * @property {String} axis 拖动的方向
	 * @value x 左右拖动
	 * @value y 上下拖动
	 * @value xy 自由拖动（默认值）
	 * @property {String} adsorption 拖动结束后吸附的方向，默认不吸附
	 * @value x 吸附在x轴
	 * @value y 吸附在y轴
	 * @property {String} defaultPosition 默认的初始位置，只有第一次加载且offset的x或y的值小于0时才生效
	 * @value center 居中
	 * @value top-left 左上角
	 * @value top-right 右上角
	 * @value bottom-right 右下角 （默认值）
	 * @value bottom-left 左下角
	 * @property {String|Number} gap 悬浮球与窗口的最小距离，单位px；
	 * @property {String|Number} gapTop 单独设置悬浮按钮与上窗口的最小距离；
	 * @property {String|Number} gapBottom 单独设置悬浮按钮与下窗口的最小距离；
	 * @property {String|Number} gapLeft 单独设置悬浮按钮与左窗口的最小距离；
	 * @property {String|Number} gapRight 单独设置悬浮按钮与右窗口的最小距离；
	 * @property {Boolean} overGap 拖动的时候按钮是否可超出 gap 的距离,拖动结束会自动回弹到正确的位置，默认true
	 * @property {Number} duration 吸附时的动画时间 单位ms，默认300
	 * @property {String} icon icon图标
	 * @property {String} iconColor 图标颜色
	 * @property {String|Number} iconSize 图标大小
	 * @property {String|Number} height 悬浮球的高度 默认60px
	 * @property {String|Number} width 悬浮球的宽度 默认60px
	 * @property {String|Number} radius 圆角值 ，默认为100%
	 * @property {String} bgColor 背景颜色，支持渐变色
	 * @property {Boolean} disabled 是否禁止拖动，默认false
	 * @property {Number} zIndex z-index 层级，默认99
	 * @property {String} customStyle 自定义style样式
	 */

	defineOptions({
		name: 'rice-float-fab'
	})
	import { useNamespace, useTouch } from "../../libs/use"
	import { addUnit, clamp, closeto, hasStrValue, getPxNum } from "../../libs/utils"
	import { FloatFabProps, FloatFabOffset, FloatFabBoundary, FloatFabWindowSize, FloatFabState } from './type.uts';

	const ns = useNamespace('float-fab')
	const touch = useTouch()
	const emit = defineEmits<{
		click : [],
		offsetChange : [position: FloatFabOffset]
	}>()

	const props = withDefaults(defineProps<FloatFabProps>(), {
		axis: 'xy',
		height: '52px',
		width: '52px',
		overGap: true,
		defaultPosition: 'bottom-right',
		duration: 300,
		iconColor: '#fff',
		iconSize: '30px',
		gap: '24px',
		disabled: false,
		customStyle: () : UTSJSONObject => ({})
	})

	//@ts-ignore
	const offset = defineModel('offset', {
		type: null as unknown as PropType<FloatFabOffset>,
		default: () => ({ x: -1, y: -1 } as FloatFabOffset)
	})

	const windowSize = reactive<FloatFabWindowSize>({
		width: 0,
		height: 0,
	})

	const state = reactive<FloatFabState>({
		x: 0,
		y: 0,
		width: 0,
		height: 0,
	})

	const lastOffset = {
		x: 0,
		y: 0
	} as FloatFabOffset

	let initialized = false
	let timer : number | null = null
	let initTimer : number | null = null
	const fabRef = shallowRef<UniElement | null>(null)
	const boundaryBottom = computed(() => getPxNum(props.gapBottom ?? props.gap))
	const boundaryRight = computed(() => getPxNum(props.gapRight ?? props.gap))


	//边界值
	const boundary = computed(() => {
		return {
			top: getPxNum(props.gapTop ?? props.gap),
			bottom: windowSize.height - state.height - boundaryBottom.value,
			left: getPxNum(props.gapLeft ?? props.gap),
			right: windowSize.width - state.width - boundaryRight.value,
		} as FloatFabBoundary
	})


	const setTransform = (x : number, y : number) => {
		fabRef.value?.style.setProperty('transform', `translate(${x}px,${y}px)`)
		fabRef.value?.style.setProperty('opacity', `1`)
	}

	const updateOffset = () => {
		offset.value = {
			x: state.x,
			y: state.y
		} as FloatFabOffset
	}

	const setPosition = () => {
		const duration = (touch.dragging.value || !initialized) ? 0 : props.duration;
		fabRef.value?.style.setProperty('transition-duration', `${duration}ms`)
		setTransform(state.x, state.y)
	}

	const getFabSize = async () => {
		const rect = await fabRef.value!.getBoundingClientRectAsync()!
		state.height = rect.height
		state.width = rect.width
	}

	function setDefPosition(position ?: string, isInit = false) {
		if (position == 'top-left') {
			state.x = boundary.value.left
			state.y = boundary.value.top
		} else if (position == 'top-right') {
			state.x = boundary.value.right
			state.y = boundary.value.top
		} else if (position == 'bottom-left') {
			state.x = boundary.value.left
			state.y = boundary.value.bottom
		} else {
			state.x = boundary.value.right
			state.y = boundary.value.bottom
		}
		setPosition()
		if (!isInit) {
			updateOffset()
		}
	}

	const updateState = (x : number, y : number) => {
		if (props.adsorption == 'x') {
			x = closeto([boundary.value.left, boundary.value.right], x)
		} else if (props.adsorption == 'y') {
			y = closeto([boundary.value.top, boundary.value.bottom], y)
		}
		x = clamp(x, boundary.value.left, boundary.value.right)
		y = clamp(y, boundary.value.top, boundary.value.bottom)
		state.x = x
		state.y = y
		setPosition()
	}

	function updatePosition(isInit = false) {
		// #ifndef APP-ANDROID
		let x = offset.value?.x ?? -1
		let y = offset.value?.y ?? -1
		// #endif
		// #ifdef APP-ANDROID
		let x = offset.value!.x
		let y = offset.value!.y
		// #endif

		//设置初始的默认位置,只有第一次加载且offset的x或y的值小于0时才生效
		if (isInit && (x < 0 || y < 0)) {
			const position = props.defaultPosition
			if (position == 'top-left') {
				setTransform(-state.width, boundary.value.top)
			} else if (position == 'top-right') {
				setTransform(windowSize.width + state.width, boundary.value.top)
			} else if (position == 'bottom-left') {
				setTransform(-state.width, boundary.value.bottom)
			} else {
				setTransform(windowSize.width + state.width, boundary.value.bottom)
			}
			initTimer = setTimeout(() => {
				initialized = true
				setDefPosition(position, isInit)
			}, 20)
		} else {
			updateState(x, y)
			updateOffset()
		}
		initialized = true
	}

	async function init(isInit = false) {
		await nextTick()
		const windowInfo = uni.getWindowInfo()
		windowSize.height = windowInfo.windowHeight
		windowSize.width = windowInfo.windowWidth
		await getFabSize()
		updatePosition(isInit)
	}

	watch(offset, () => {
		const isSame = offset.value!.x == state.x && offset.value!.y == state.y
		if (isSame || touch.dragging.value) return
		updatePosition()
	}, {
		deep: true,
	})

	watch(() : (any | null)[] =>
		[props.gap, props.gapTop, props.gapBottom, props.gapLeft, props.gapRight, props.overGap],
		() => {
			if (touch.dragging.value) return
			updateState(state.x, state.y)
		}, {
		deep: true,
	})

	watch(() : (string | number)[] => [props.height, props.width], async () => {
		if (touch.dragging.value) return
		await nextTick()
		await getFabSize()
		updateState(state.x, state.y)
	}, {
		deep: true
	})

	// #ifndef MP-WEIXIN


	const onTouchstart = (e : UniTouchEvent) => {
		touch.start(e)
		if (props.disabled) return
		fabRef.value!.style.setProperty('transition-duration', '0ms')
		lastOffset.x = state.x
		lastOffset.y = state.y
		getFabSize()
	}

	const onTouchmove = (e : UniTouchEvent) => {
		touch.move(e)
		if (props.disabled || touch.isTap.value) return
		let nextX = lastOffset.x + touch.deltaX.value
		let nextY = lastOffset.y + touch.deltaY.value
		const axis = props.axis
		if (axis == 'x' || axis == 'xy') {
			if (props.overGap) {
				nextX = clamp(nextX, 0, boundary.value.right + boundaryRight.value)
			} else {
				nextX = clamp(nextX, boundary.value.left, boundary.value.right)
			}
			state.x = nextX
		}
		if (axis == 'y' || axis == 'xy') {
			if (props.overGap) {
				nextY = clamp(nextY, 0, boundary.value.bottom + boundaryBottom.value)
			} else {
				nextY = clamp(nextY, boundary.value.top, boundary.value.bottom)
			}
			state.y = nextY
		}
		updateOffset()
		setPosition()
		e.preventDefault()
	}

	const onTouchend = () => {
		touch.end()
		//App端手指按下后在组件区域内移动不会取消tap/click事件的触发，移动到组件区域外才会取消tap/click事件的触发。
		//为了区分 touchmove事件和click事件，使用touchmove移动的距离阈值来判断是否为点击
		if (touch.isTap.value) {
			emit('click')
		} else {
			if (props.disabled) return
			updateState(state.x, state.y)
			updateOffset()
			if (lastOffset.x != state.x || lastOffset.y != state.y) {
				emit('offsetChange', { x: state.x, y: state.y } as FloatFabOffset)
			}
		}
	}

	// #endif

	const floatFabStyle = computed(() => {
		const css = new Map<string, string | number>()
		css.set('height', addUnit(props.height))
		css.set('width', addUnit(props.width))
		//android 如果在css里面设置border-radius，这里设置的radius会无效，统一在这里设置radius值
		css.set('border-radius', props.radius == null ? '999px' : addUnit(props.radius!))
		if (props.zIndex != null) css.set('z-index', props.zIndex!)
		if (hasStrValue(props.bgColor)) css.set('background', props.bgColor!)

		return css
	})

	const fabClass = computed(() => {
		return [
			ns.b(""),
			ns.theme()
		]
	})

	const resize = async () => {
		init(true)
	}


	onMounted(() => {
		timer = setTimeout(() => {
			init(true)
		}, 200)
		// #ifdef WEB
		window.addEventListener('resize', resize)
		// #endif
	})


	onUnmounted(() => {
		if (timer != null) clearTimeout(timer!)
		if (initTimer != null) clearTimeout(initTimer!)
		// #ifdef WEB
		window.removeEventListener('resize', resize)
		// #endif
	})


	const setDefaultPosition = (position : string) => {
		setDefPosition(position, false)
	}

	// #ifdef MP-WEIXIN
	const mpProps = computed(() => {
		return {
			axis: props.axis,
			adsorption: props.adsorption,
			overGap: props.overGap,
			disabled: props.disabled,
			duration: props.duration,
			gapRight: boundaryRight.value,
			gapBottom: boundaryBottom.value,
		}
	})

	const _wxsIsDragging = (state) => {
		touch.dragging.value = state.dragging ?? false
	}

	const _updateOffset = (params : FloatFabState) => {
		state.x = params.x
		state.y = params.y
		updateOffset()
	}

	const _emitOffsetChange = (params : FloatFabState) => {
		emit('offsetChange', params)
	}

	const handleClick = () => {
		emit('click')
	}

	// #endif

	defineExpose({
		resize,
		setDefaultPosition,
		// #ifdef MP-WEIXIN
		_wxsIsDragging,
		_updateOffset,
		_emitOffsetChange,
		// #endif
	})
</script>

<!-- #ifdef MP-WEIXIN -->
<script module="touch" lang="wxs" src="../../libs/use/useTouch/touch.wxs"></script>
<script module="wxs" lang="wxs" src="./wx.wxs"></script>
<!-- #endif -->


<style scoped lang="scss">
	.rice-float-fab {
		position: fixed;
		left: 0;
		/* #ifndef WEB */
		top: 0;
		/* #endif */
		/* #ifdef WEB */
		top: var(--uni-safe-area-inset-top);
		user-select: none;
		cursor: pointer;
		/* #endif */

		z-index: 998;
		align-items: center;
		justify-content: center;
		transition-property: all;
		transform: translate(0, 0);
		background: var(--rice-primary-color);
		pointer-events: auto;
		/* #ifndef APP */
		touch-action: none;

		/* #endif */
		opacity: 0;

	}
</style>